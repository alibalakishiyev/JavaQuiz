<!DOCTYPE html>
<html lang="az">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D…ôrs: ≈û…ôkil Tensor-u v…ô CNN-l…ôr</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f9;
            color: #333;
        }
        h1, h2 {
            color: #2c3e50;
        }
        pre {
            background-color: #333; /* Kod √º√ß√ºn t√ºnd fon */
            color: #fff; /* Aƒü r…ôngli m…ôtn */
            padding: 10px; /* Kod √º√ß√ºn i√ß margin */
            border-radius: 5px; /* Yuvarlaq k√ºncl…ôr */
            font-family: Consolas, monaco, monospace; /* Kod ≈ürifti */
            font-size: 16px; /* ≈ûrift √∂l√ß√ºs√º */
            overflow: auto; /* Uzun kod √º√ß√ºn skroll */
            white-space: pre-wrap; /* Uzun kod x…ôttind…ô sarmak */
        }
        p {
            line-height: 1.6;
        }
        strong {
            color: #e74c3c;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>≈û…ôkil Tensor-u v…ô CNN-l…ôr</h1>
    <div class="section">
        <p>üé® <strong>≈û…ôkil Tensor-u n…ôdir?</strong></p>
        <p>≈û…ôkil, √ßox√∂l√ß√ºl√º …ôd…ôdl…ôrd…ôn ibar…ôt bir matrisi t…ômsil edir. Bu …ôd…ôdl…ôr ad…ôt…ôn 0 il…ô 1 arasƒ±nda olur v…ô ≈ü…ôkilin m√ºxt…ôlif x√ºsusiyy…ôtl…ôrini (m…ôs…ôl…ôn, r…ông intensivliyini) g√∂st…ôrir.</p>
    </div>

    <div class="section">
        <h2>üé® RGB ≈û…ôkil √º√ß√ºn:</h2>
        <ul>
            <li>R (Red)</li>
            <li>G (Green)</li>
            <li>B (Blue)</li>
        </ul>
        <p>Bu √º√ß …ôsas r…ông kanalƒ± il…ô i≈ül…ôyirik.</p>
        <p>M…ôs…ôl…ôn, tensor √∂l√ß√ºs√º <code>torch.Size([3, 64, 64])</code> g√∂st…ôrir:</p>
        <ul>
            <li>3 kanal (RGB)</li>
            <li>64x64 √∂l√ß√ºl√º ≈ü…ôkil</li>
        </ul>
    </div>

    <div class="section">
        <h2>üß† 3. CNN (Convolutional Neural Network) n…ôdir?</h2>
        <p>CNN-l…ôr ≈ü…ôkill…ôrl…ô i≈ül…ôm…ôk √º√ß√ºn …ôn g√ºcl√º neyron ≈ü…ôb…ôk…ôl…ôrd…ôndir.</p>
        <p><strong>CNN nec…ô i≈ül…ôyir?</strong></p>
        <ul>
            <li><strong>Convolution Layer:</strong> ≈û…ôkilin √ºz…ôrind…ôn ki√ßik filtrl…ôr ke√ßir, x√ºsusiyy…ôtl…ôri √ßƒ±xarƒ±r (k…ônarlar, r…ông d…ôyi≈üiklikl…ôri v…ô s.).</li>
            <li><strong>Activation Layer (ReLU):</strong> Aktivlik funksiyasƒ±dƒ±r, ≈ü…ôb…ôk…ôy…ô qeyri-x…ôtti x√ºsusiyy…ôt verir.</li>
            <li><strong>Pooling Layer:</strong> ≈û…ôkili daha ki√ßik √∂l√ß√ºy…ô salƒ±r, …ôsas m…ôlumatƒ± saxlayƒ±r.</li>
            <li><strong>Fully Connected Layer (FC):</strong> B√ºt√ºn √ßƒ±xƒ±≈ülarƒ± yƒ±ƒüƒ±b n…ôtic…ô verir (m…ôs…ôl…ôn: bu ≈ü…ôkil "pi≈üikdir").</li>
        </ul>
    </div>

    <div class="section">
        <h2>‚úÖ 4. CNN Kod n√ºmun…ôsi (MNIST ≈ü…ôkil datasƒ± il…ô)</h2>
        <p>ƒ∞ndi CNN kodunu yazƒ±ram ‚Äî h…ôr s…ôtrini d…ô izah ed…ôc…ôm:</p>
        <pre>
import torch
import torch.nn as nn
import torch.nn.functional as F
import torchvision
import torchvision.transforms as transforms

transform = transforms.Compose([
    transforms.ToTensor(),
    transforms.Normalize((0.5,), (0.5,))
])

trainset = torchvision.datasets.MNIST(root='./data', train=True, download=True, transform=transform)
trainloader = torch.utils.data.DataLoader(trainset, batch_size=32, shuffle=True)

class MyCNN(nn.Module):
    def __init__(self):
        super(MyCNN, self).__init__()
        self.conv1 = nn.Conv2d(in_channels=1, out_channels=8, kernel_size=3)
        self.pool = nn.MaxPool2d(2, 2)
        self.conv2 = nn.Conv2d(8, 16, 3)
        self.fc1 = nn.Linear(16 * 5 * 5, 64)
        self.fc2 = nn.Linear(64, 10)

    def forward(self, x):
        x = self.pool(F.relu(self.conv1(x)))
        x = self.pool(F.relu(self.conv2(x)))
        x = x.view(-1, 16 * 5 * 5)
        x = F.relu(self.fc1(x))
        x = self.fc2(x)
        return x

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
model = MyCNN().to(device)

criterion = nn.CrossEntropyLoss()
optimizer = torch.optim.Adam(model.parameters(), lr=0.001)

for epoch in range(2):
    running_loss = 0.0
    for inputs, labels in trainloader:
        inputs, labels = inputs.to(device), labels.to(device)

        optimizer.zero_grad()
        outputs = model(inputs)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()

        running_loss += loss.item()
    print(f"Epoch {epoch + 1}, Loss: {running_loss:.3f}")
        </pre>
    </div>

    <div class="task">
        <p>‚úÖ Bu kod n…ô edir?</p>
        <ul>
            <li>MNIST-d…ôn 28x28 ≈ü…ôkill…ôri Tensor formatƒ±nda alƒ±r.</li>
            <li>CNN t…ôtbiq edir (2 convolution qatlƒ±).</li>
            <li>GPU varsa istifad…ô edir.</li>
            <li>2 epoch sad…ô √∂yr…ônm…ô aparƒ±r v…ô itki d…ôy…ôrini (loss) √ßap edir.</li>
        </ul>
    </div>
</div>
</body>
</html>
